<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../px-vis/px-vis-behavior-common.html">
<link rel="import" href="../px-vis/px-vis-behavior-d3.html">
<link rel="import" href="../px-vis/px-vis-scale.html">
<link rel="import" href="../px-vis/px-vis-svg.html">


<dom-module id="px-vis-heatmap-cell">
  <script>
    Polymer({

      is: 'px-vis-heatmap-cell',

      behaviors: [
        PxVisBehavior.commonMethods,
        PxVisBehavior.completeSeriesConfig,
        PxVisBehavior.svgDefinition,
        PxVisBehaviorD3.axes,
        PxVisBehaviorD3.domainUpdate
      ],

      properties: {

        /**
         * Data used to draw the cell.
         */
        data: {
          type: Object,
          value: {}
        },

        seriesKey: {
          type: String
        },

        /**
         * True will render the data value in the cell.
         */
        showCellValue: {
          type: Boolean,
          value: false
        },

        /**
         * Fill color of cell. If set, this color will override the default color
         * which is calculated by the cell value and the color scale.
         */
        fillColor: {
          type: String
        },

        /**
         * Stroke color of cell.
         */
        strokeColor: {
          type: String
        },

        /**
         * Text alignment for the cell value text. Choice:
         * 'start'
         * 'middle'
         * 'end'
         */
        textAlign: {
          type: String,
          value: 'middle'
        },

        /**
         * Color of text inside cell.
         */
        textColor: {
          type: String,
          value: '#000'
        },

        /**
         * Size of text inside cell.
         */
        fontSize: {
          type: String
        },

        /**
         * Font family of text inside cell.
         */
        fontFamily: {
          type: String
        },

        /**
         * A delay time used for drawing/updating the cell.
         * This helps ensure the draw function is not called too
         * many times when not needed.
         */
        drawDebounceTime: {
          type: Number,
          value: 50
        },

        _svgGroup: {
          type: Object,
          value: {}
        }

      },

      observers: [
        '_draw(data, showCellValue, svg, x, y, domainChanged, completeSeriesConfig, seriesKey)',
        '_updateColors(fillColor, strokeColor)'
      ],

      detached: function() {
        // remove our data from svg
        if (this._svgGroup) {
          this._svgGroup.remove();
        }
      },

      /**
       * Draw or update the cell.
       */
      _draw: function() {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }
        this.debounce('drawDebounce', function() {
          this._drawDebounced();
        }, this.drawDebounceTime);
      },

      /**
       * Draw but delay by debounce time.
       */
      _drawDebounced: function() {
        // remove previous drawing
        if (!this._isObjEmpty(this._svgGroup)) {
          this._svgGroup.remove();
        }
        // if data is empty, leave drawing empty
        if (!this.data) {
          console.warn('Cannot draw without data');
          return;
        }
        if (!this.x || !this.y) {
          console.warn('Cannot draw without valid x and y functions');
          return;
        }
        // create svg group and append rectangle to represent our cell
        this._svgGroup = this.svg.append('g');
        // convert chart values to svg points
        const svgData = {
          x: this.x(this._getValue('x')),
          y: this.y(this._getValue('y')),
          width: this.x.bandwidth(),
          height: this.y.bandwidth()
        };

        if (!this._isValidSvgPoints(svgData)) {
          console.warn('Skipping draw, invalid svg points');
          return;
        }

        // calc colors
        const fillColor = this.fillColor || this._calcCellColor();

        this._appendRectangle(this._svgGroup, svgData.x, svgData.y,
          svgData.width, svgData.height, this.strokeColor, fillColor);
        // write value
        if (this.showCellValue) {
          const textPos = {
            x: svgData.x + svgData.width / 2,
            y: svgData.y + svgData.height / 2
          };
          this._appendText(this._svgGroup, textPos.x, textPos.y,
            this._getValue('value'), this.textColor, this.textAlign, this.fontFamily, this.fontSize);
        }
      },

      /**
       * Gets value from this.data object using keys in the completeSeriesConfig.
       */
      _getValue: function(key) {
        return this.data[this.completeSeriesConfig[this.seriesKey][key]];
      },

      _isValidSvgPoints: function(obj) {
        for (const i in obj) {
          if (isNaN(obj[i]) || obj[i] < 0) {
            return false;
          }
        }
        return true;
      },

      _updateColors() {
        // TODO: change color without re-drawing entirely
        this._draw();
      },

      /**
       * Draw rectangle to existing svg element. Coordinates passed in by 'data.x' and 'data.y'
       * should define the upper left point of the rectangle.
       */
      _appendRectangle: function(svg, x, y, width, height, strokeColor, fillColor) {
        svg.append('rect')
          .attr('x', x)
          .attr('y', y)
          .attr('width', width)
          .attr('height', height)
          .attr('stroke', strokeColor)
          .attr('fill', fillColor);
      },

      _appendText: function(svg, x, y, text, color, textAnchor, fontFamily, fontSize) {
        const textEl = svg.append('text')
          .text(text)
          .attr('x', x)
          .attr('y', y);
        if (color) {
          textEl.attr('fill', color);
        }
        if (textAnchor) {
          textEl.attr('text-anchor', textAnchor);
        }
        if (fontFamily) {
          textEl.attr('font-family', fontFamily);
        }
        if (fontSize) {
          textEl.attr('font-size', fontSize);
        }
      },

      _calcCellColor: function(value) {
        // TODO: impl value to color
        return '#' + ((1 << 24) * Math.random() | 0).toString(16);
      },

    });
  </script>
</dom-module>
