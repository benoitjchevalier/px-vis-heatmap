<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../px-vis/px-vis-scale.html">
<link rel="import" href="../px-vis/px-vis-svg.html">
<link rel="import" href="../px-vis/px-vis-axis.html">

<link rel="import" href="../px-vis/px-vis-behavior-colors.html">
<link rel="import" href="../px-vis/px-vis-behavior-common.html">
<link rel="import" href="../px-vis/px-vis-behavior-chart.html">

<link rel="import" href="px-vis-heatmap-cell.html">


<dom-module id="px-vis-heatmap">
  <template>
    <px-vis-svg
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      svg="{{svg}}">
    </px-vis-svg>
    <px-vis-scale
      x-axis-type="[[xAxisType]]"
      y-axis-type="[[yAxisType]]"
      complete-series-config="[[completeSeriesConfig]]"
      chart-extents="[[chartExtents]]"
      data-extents="[[dataExtents]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      chart-data="[[chartData]]"
      x="{{x}}"
      y="{{y}}"
      domain-changed="{{domainChanged}}">
    </px-vis-scale>
    <!-- y axis -->
    <px-vis-axis
      id="yAxis"
      svg="[[svg]]"
      axis="[[y]]"
      margin="[[margin]]"
      width="[[width]]"
      height="[[height]]"
      title="Y Axis"
      orientation="left"
      label-position="center"
      complete-series-config="[[completeSeriesConfig]]"
      muted-series=[[mutedSeries]]
      domain-changed="[[domainChanged]]">
    </px-vis-axis>
    <!-- x axis -->
    <px-vis-axis
      id="xAxis"
      svg="[[svg]]"
      axis="[[x]]"
      margin="[[margin]]"
      width="[[width]]"
      height="[[height]]"
      title="X Axis"
      orientation="bottom"
      label-position="center"
      complete-series-config="[[completeSeriesConfig]]"
      muted-series=[[mutedSeries]]
      domain-changed="[[domainChanged]]">
    </px-vis-axis>
    <!-- heatmap cells -->
    <template is="dom-repeat" items="[[_cellData]]">
      <px-vis-heatmap-cell
        data="[[item]]"
        width="[[_cellWidth]]"
        height="[[_cellHeight]]"
        fill-color="[[item.fillColor]]"
        stroke-color="[[item.strokeColor]]"
        svg="[[svg]]"
        x="[[x]]"
        y="[[y]]"
        domain-changed="[[domainChanged]]">
      </px-vis-heatmap-cell>
    </template>
  </template>
  <script>
    Polymer({

      is: 'px-vis-heatmap',

      behaviors: [
        PxColorsBehavior.dataVisColors,
        PxColorsBehavior.dataVisColorTheming,
        PxColorsBehavior.getSeriesColors,
        PxVisBehavior.axisTypes,
        PxVisBehavior.baseSize,
        PxVisBehavior.chartExtents,
        PxVisBehavior.completeSeriesConfig,
        PxVisBehavior.dataset,
        PxVisBehavior.dataExtents,
        PxVisBehavior.margins,
        PxVisBehavior.observerCheck,
        PxVisBehaviorD3.domainUpdate,
        PxVisBehaviorChart.axisConfigs,
        PxVisBehaviorChart.subConfiguration
      ],

      properties: {

        /**
        * Container for the data object that drives the chart.
        */
        chartData: {
          type: Array
        },

        /**
        * The width of the elem; generally the width of the charting area for most components
        */
        width: {
          type: Number,
          value: 500,
          notify: true
        },

        /**
        * The height of the component; generally the height of the charting area for most components.
        */
        height: {
          type: Number,
          value: 500,
          notify: true
        },

        /**
        * Defines the base margin for the chart. Calcs are run to add to the
        * margin to accommodate axes and other elements which exist within the SVG frame,
        * but outside the chart frame.
        */
        margin: {
          type: Object,
          value: function() {
            return {
              'top': 10,
              'right': 10,
              'bottom': 50,
              'left': 50
            };
          }
        },

        _cellData: {
          type: Array
        },

        _cellWidth: {
          type: Number,
          value: 1
        },

        _cellHeight: {
          type: Number,
          value: 1
        },

        _colorsAreSet: {
          type: Boolean,
          value: false
        }

      },

      observers: [
        '_updateCellData(chartData, chartData.*, domainChanged)',
        '_updateSeriesConfig(_colorsAreSet)'
      ],

      listeners: {
        'px-data-vis-colors-applied': '_colorsSet'
      },

      _updateCellData: function() {
        if (!this.chartData) {
          return;
        }
        // check if we need to re-calc the extents, updating dataExtent everytime
        // will cause a loop as it causes the domainChanged event to fire each time
        const newExts = this._calcExtents(this.chartData);
        if (!this.dataExtents || !this._isExtEqual(this.dataExtents, newExts)) {
          this.dataExtents = newExts;
        }
        if (this.x && this.y) {
          // TODO: unit sizes of 1 will not work when we change to a string based scale (ordinal/scaleBand)
          const xUnitSize = 1;
          const yUnitSize = 1;
          // calc cell width and height
          this._cellWidth = this.x(this.dataExtents.x[0] + xUnitSize);
          this._cellHeight = this.y(this.dataExtents.y[1] - yUnitSize);
          // calc rest of data for each cell
          this.set('_cellData', this._calcCellData(this.chartData));
        }
      },

      /**
       * Calculate the min/max for both x and y axis based on the
       * values found in the chart data.
       */
      _calcExtents: function(chartData) {
        const exts = {
          x: [Infinity, -Infinity],
          y: [Infinity, -Infinity]
        };
        chartData.forEach((data) => {
          exts.x[0] = Math.min(data.x, exts.x[0]);
          exts.x[1] = Math.max(data.x, exts.x[1]);
          exts.y[0] = Math.min(data.y, exts.y[0]);
          exts.y[1] = Math.max(data.y, exts.y[1]);
        });
        // add 1 to both max values because we need an addition unit to draw cell
        exts.x[1]++;
        exts.y[1]++;
        return exts;
        // TODO: change to this impl once string based axis types are impl (oridinal/scaleBand)
        // impl for string based axis
        // const exts = {
        //   x: [],
        //   y: []
        // };
        // chartData.forEach((data) => {
        //   if (exts.x.indexOf(data.x) < 0) {
        //     exts.x.push(data.x);
        //   }
        //   if (exts.y.indexOf(data.y) < 0) {
        //     exts.y.push(data.y);
        //   }
        // });
        // return exts;
      },

      /**
       * Compares two extents objects and returns true if they are
       * equal.
       */
      _isExtEqual: function(extA, extB) {
        if (!extA && extB || extA && !extB) {
          return false;
        }
        if (!extA && !extB) {
          return true;
        }
        return extA.x[0] === extB.x[0]
            && extA.x[1] === extB.x[1]
            && extA.y[0] === extB.y[0]
            && extA.y[1] === extB.y[1];
      },

      /**
       * Use chartData to generate an array of cell data objects.
       * Each object represents a cell in the heatmap.  The x and y
       * values are svg coord locations.
       */
      _calcCellData: function(chartData) {
        const cellData = [];
        chartData.forEach((data) => {
          cellData.push({
            // x,y represent top left corner of rectangle
            x: this.x(data.x),
            y: this.y(data.y + 1),
            fillColor: this._calcCellColor(data.value),
            strokeColor: '#FFF'
          });
        });
        return cellData;
      },

      _calcCellColor: function(value) {
        // TODO: impl value to color
        return '#' + ((1 << 24) * Math.random() | 0).toString(16);
      },

      _updateSeriesConfig: function() {
        this.debounce('_updateSeriesConfig', function() {
          if (this._colorsAreSet) {
            this.set('completeSeriesConfig', {
              'mySeries': {
                'name': 'My-Series',
                'x': 'x',
                'y': 'y',
                'color': this._getColor(0)
              }
            });
          }
        }, 10);
      },

      _colorsSet: function() {
        this.set('_colorsAreSet', true);
      }

    });
  </script>
</dom-module>
