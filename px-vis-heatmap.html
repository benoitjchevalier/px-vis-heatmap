<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../px-vis/px-vis-scale.html">
<link rel="import" href="../px-vis/px-vis-svg-canvas.html">
<link rel="import" href="../px-vis/px-vis-axis.html">
<link rel="import" href="../px-tooltip/px-tooltip.html">

<link rel="import" href="../px-vis/px-vis-behavior-colors.html">
<link rel="import" href="../px-vis/px-vis-behavior-common.html">
<link rel="import" href="../px-vis/px-vis-behavior-chart.html">
<link rel="import" href="../px-vis/px-vis-behavior-d3.html">

<link rel="import" href="px-vis-heatmap-cell.html">
<link rel="import" href="px-vis-heatmap-legend.html">

<!-- <link rel="import" href="../px-vis/css/px-vis-styles.html"> -->
<link rel="import" href="css/px-vis-heatmap-styles.html">


<dom-module id="px-vis-heatmap">
  <template>
    <style include="px-vis-heatmap-styles"></style>

    <!-- Media query to determine if context browser should collapse -->
    <template is="dom-if" if="[[_collapseQueryIsValid(collapseAt)]]">
      <iron-media-query query$="(max-width: {{_getCollapseQuery(collapseAt)}})" query-matches="{{collapsed}}"></iron-media-query>
    </template>

    <!--
      TODO: use _chartWrapperClass

      Using _chartWrapperClass is causing weird positioning when preventResize
      is set to false. It could have something to do with the demo page.

      <div id="wrapper" class$="{{_chartWrapperClass}}">
    -->
    <div id="wrapper" class="flex wrapper">

      <px-vis-svg-canvas
        width="[[_internalWidth]]"
        height="[[_internalHeight]]"
        margin="[[margin]]"
        svg="{{svg}}"
        canvas-context="{{canvasContext}}">
      </px-vis-svg-canvas>
      <px-vis-scale
        id="scale"
        x-axis-type="[[xAxisType]]"
        y-axis-type="[[yAxisType]]"
        complete-series-config="[[completeSeriesConfig]]"
        chart-extents="[[chartExtents]]"
        data-extents="[[dataExtents]]"
        width="[[_internalWidth]]"
        height="[[_internalHeight]]"
        margin="[[margin]]"
        chart-data="[[chartData]]"
        x="{{x}}"
        y="{{y}}"
        scale-padding="[[scalePadding]]"
        domain-changed="{{domainChanged}}">
      </px-vis-scale>
      <!-- y axis -->
      <px-vis-axis
        id="yAxis"
        svg="[[layer.1]]"
        axis="[[y]]"
        axis-type="[[yAxisType]]"
        margin="[[margin]]"
        width="[[_internalWidth]]"
        height="[[_internalHeight]]"
        orientation="left"
        label-position="center"
        tick-size-inner="0"
        prevent-series-bar
        complete-series-config="[[completeSeriesConfig]]"
        muted-series=[[mutedSeries]]
        domain-changed="[[domainChanged]]">
      </px-vis-axis>
      <!-- x axis -->
      <px-vis-axis
        id="xAxis"
        svg="[[layer.1]]"
        axis="[[x]]"
        axis-type="[[xAxisType]]"
        margin="[[margin]]"
        width="[[_internalWidth]]"
        height="[[_internalHeight]]"
        orientation="bottom"
        label-position="center"
        tick-size-inner="0"
        prevent-series-bar
        complete-series-config="[[completeSeriesConfig]]"
        muted-series=[[mutedSeries]]
        domain-changed="[[domainChanged]]">
      </px-vis-axis>
      <!-- heatmap cells -->
      <!-- to use svg, remove canvas-context and add svg="[[svg]]" -->
      <!-- <template is="dom-repeat" items="[[chartData]]">
        <px-vis-heatmap-cell restamp
          data="[[item]]"
          show-cell-value="[[showCellValue]]"
          color-scale="[[_colorScale]]"
          canvas-context="[[canvasContext]]"
          x="[[x]]"
          y="[[y]]"
          margin="[[margin]]"
          width="[[width]]"
          height="[[height]]"
          color-scale="[[_colorScale]]"
          chart-extents="[[chartExtents]]"
          data-extents="[[dataExtents]]"
          orientation="[[_legendOrientation]]"
          complete-series-config="[[completeSeriesConfig]]"
          domain-changed="[[domainChanged]]"
          on-mouseover="_handleCellMouseover"
          on-mouseout="_handleCellMouseout"
          on-click="_handleCellClick">
        </px-vis-heatmap-cell>
      </template> -->

      <template is="dom-if" if="[[showLegend]]" restamp>
        <px-vis-heatmap-legend
          id="legend"
          svg="[[svg]]"
          x="[[x]]"
          y="[[y]]"
          margin="[[margin]]"
          width="[[_internalWidth]]"
          height="[[_internalHeight]]"
          color-scale="[[_colorScale]]"
          chart-extents="[[chartExtents]]"
          data-extents="[[dataExtents]]"
          orientation="[[_legendOrientation]]"
          complete-series-config="[[completeSeriesConfig]]"
          domain-changed="[[domainChanged]]">
        </px-vis-heatmap-legend>
      </template>

    </div><!-- /wrapper -->

    <!-- tooltip -->
    <px-tooltip
      id="tooltip"
      orientation="top"
      delay="[[tooltipDelay]]"
      ignore-target-events>
      <div id="tooltipContent"></div>
    </px-tooltip>
  </template>
  <script>
    Polymer({

      is: 'px-vis-heatmap',

      behaviors: [
        PxColorsBehavior.dataVisColors,
        PxColorsBehavior.dataVisColorTheming,
        PxColorsBehavior.getSeriesColors,
        PxVisBehavior.axisTypes,
        PxVisBehavior.baseSize,
        PxVisBehavior.chartExtents,
        PxVisBehavior.completeSeriesConfig,
        PxVisBehavior.dataset,
        PxVisBehavior.dataExtents,
        PxVisBehavior.margins,
        PxVisBehavior.observerCheck,
        PxVisBehavior.updateStylesOverride,
        PxVisBehaviorD3.canvasContext,
        PxVisBehaviorD3.domainUpdate,
        PxVisBehaviorChart.axisConfigs,
        PxVisBehaviorChart.chartAutoResize,
        PxVisBehaviorChart.layers,
        PxVisBehaviorChart.subConfiguration
      ],

      properties: {

        /**
        * Container for the data object that drives the chart.
        */
        chartData: {
          type: Array
        },

        /**
         * Key that is tied to the seriesConfig.
         */
        seriesKey: {
          type: String
        },

        /**
        * The width of the elem; generally the width of the charting area for most components
        */
        width: {
          type: Number,
          value: 500,
          notify: true
        },

        /**
        * The height of the component; generally the height of the charting area for most components.
        */
        height: {
          type: Number,
          value: 500,
          notify: true
        },

        /**
        * Defines the base margin for the chart. Calcs are run to add to the
        * margin to accommodate axes and other elements which exist within the SVG frame,
        * but outside the chart frame.
        */
        margin: {
          type: Object,
          value: function() {
            return {
              'top': 10,
              'right': 100,
              'bottom': 50,
              'left': 50
            };
          }
        },

        /**
         * If true, the heatmap will always show cells as squares. The shortest
         * of the x and y axis will be used for the length.
         */
        squareMode: {
          type: Boolean,
          value: false
        },

        showLegend: {
          type: Boolean,
          value: true
        },

        /**
         * Padding between boxes.
         */
        scalePadding: {
          type: Number,
          value: 0
        },

        /**
         * Padding between boxes and axis.
         */
        paddingOuter: {
          type: Number,
          value: 0
        },

        /**
         * Show the point value inside each cell.
         */
        showCellValue: {
          type: Boolean,
          value: false
        },

        /**
         * Colors to use for the heatmap.
         */
        colors: {
          type: Array,
          value: function() {
            return [
              'lightblue',
              'blue'
            ];
          }
        },

        /**
         * Configuration object passed directly to the color scale legend.
         * See px-vis-heatmap-legend.html for available properties.
         */
        legendConfig: {
          type: Object
        },

        tooltipDelay: {
          type: Number,
          value: 0
        },

        /**
         * Delay draw by this amount of milliseconds.
         * Useful for avoiding mutliple quick redraws.
         */
        drawDebounceTime: {
          type: Number,
          value: 100
        },

        /**
        * The width below which the context browser will collapse into a mobile
        * friendly menu that slides up from the bottom of the page. Use a number
        * (e.g. `450`) which will be converted to a pixel value (e.g. '450px').
        *
        * If no value is provided, the context browser will not collapse
        * automatically. The collapsed attribute can also be used to manually
        * collapse and un-collapse the context browser.
        */
        collapseAt: {
          type: Number
        },

        /**
        * Watch for changes to determine if the context browser is collapsed.
        */
        collapsed: {
          type: Boolean,
          observer: '_collapsedChanged',
          reflectToAttribute: true,
          notify: true
        },

        /**
         * Color of cell border. Set by series config object or css var.
         */
        cellBorderColor: {
          type: String
        },

        /**
         * Width of cell border. Set by series config object or css var.
         */
        cellBorderWidth: {
          type: String
        },

        /**
         * Color of text used for cell value. Set by series config object or css var.
         */
        cellTextColor: {
          type: String
        },

        /**
         * Size of text used for cell value. Set by series config object or css var.
         */
        cellTextSize: {
          type: String
        },

        _cellData: {
          type: Array
        },

        _colorsAreSet: {
          type: Boolean,
          value: false
        },

        _colorScale: {
          type: Function
        },

        _legendOrientation: {
          type: String
        },

        _internalWidth: {
          type: Number
        },

        _internalHeight: {
          type: Number
        }

      },

      observers: [
        '_drawCells(margin, chartData.*, showCellValue, x, y, domainChanged, completeSeriesConfig, seriesKey, _colorScale)',
        '_updateDataExtents(chartData, chartData.*, paddingOuter)',
        '_updateSeriesConfig(seriesConfig)',
        '_updateSeriesConfig(_colorsAreSet)',
        '_updateSeriesKey(seriesKey)',
        '_updateColorScale(chartData.*, colors.*, domainChanged)',
        '_updateInternalSize(squareMode, width, height, margin.*)',
        '_xAxisConfigChanged(xAxisConfig)',
        '_yAxisConfigChanged(yAxisConfig)',
        '_legendConfigChanged(legendConfig)',
        '_resolveCssVars(_stylesUpdated)'
      ],

      listeners: {
        'px-data-vis-colors-applied': '_colorsSet',
        'iron-resize': '_onIronResize'
      },

      ready: function() {
        this.set('numberOfLayers', 5);
        this.xAxisType = 'scaleBand';
        this.yAxisType = 'scaleBand';
        this.tooltipContent = this.$.tooltip.querySelector('#tooltipContent');
      },

      _drawCells: function() {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }
        this.debounce('chart-drawn-debounce', () => {
          this.canvasContext.pxClearCanvas();
          this.chartData.forEach((d) => {
            this.canvasContext.beginPath();
            this.canvasContext.rect(this.x(d.x), this.y(d.y), this.x.bandwidth(), this.y.bandwidth());
            this.canvasContext.fillStyle = this._colorScale(d.value);
            this.canvasContext.fill();
            // draw value if needed
            if (this.showCellValue) {
              const xPos = this.x(d.x) + this.x.bandwidth() / 2;
              const yPos = this.y(d.y) + this.y.bandwidth() / 2;
              this.canvasContext.beginPath();
              this.canvasContext.font = '12px Arial';
              this.canvasContext.fillStyle = 'black';
              this.canvasContext.textAlign = 'center';
              this.canvasContext.textBaseline = 'middle';
              this.canvasContext.fillText(d.value, xPos, yPos, this.x.bandwidth());
            }
          });
          // fire rendered event
          this.fire('chart-drawn', {
            heatmap: this
          });
        }, this.drawDebounceTime);
      },

      _collapseQueryIsValid(query) {
        if (typeof query === 'number') {
          return true;
        }
        if (typeof query === 'string' && query.slice(-2) === 'px' && !isNaN(parseInt(query))) {
          return true;
        }
        return false;
      },

      _getCollapseQuery(collapseAt) {
        if (typeof collapseAt === 'number') {
          return collapseAt + 'px';
        }
        if (typeof collapseAt === 'string' && collapseAt.slice(-2) === 'px' || !isNaN(parseInt(collapseAt))) {
          return collapseAt;
        }
      },

      _collapsedChanged() {
        this.set('_legendOrientation', this.collapsed ? 'bottom' : 'right');
      },

      _onIronResize: function() {
        this.debounce('ironresize', function() {
          // make sure we are not preventing resize in case it changed while debouncing
          if (this.preventResize) {
            return;
          }
          const wrapperRect = this.$.wrapper.getBoundingClientRect();
          this.set('width', wrapperRect.width);
          this.set('height', wrapperRect.height);
        }, this.debounceResizeTiming);
      },

      _updateDataExtents: function() {
        if (!this.chartData || !this.x || !this.y) {
          return;
        }
        this.dataExtents = this._calcExtents(this.chartData);
        if (this.x && this.y) {
          this.x.paddingOuter(this.paddingOuter);
          this.y.paddingOuter(this.paddingOuter);
        }
      },

      /**
       * Calculate the min/max for both x and y axis based on the
       * values found in the chart data.
       */
      _calcExtents: function(chartData) {
        const exts = {
          x: [],
          y: [],
          value: [Infinity, -Infinity]
        };
        chartData.forEach((data) => {
          if (exts.x.indexOf(data.x) < 0) {
            exts.x.push(data.x);
          }
          if (exts.y.indexOf(data.y) < 0) {
            exts.y.push(data.y);
          }
          exts.value[0] = Math.min(exts.value[0], data.value);
          exts.value[1] = Math.max(exts.value[1], data.value);
        });
        return exts;
      },

      /**
       * Compares two extents objects and returns true if they are
       * equal.
       */
      _isExtEqual: function(extA, extB) {
        if (!extA && extB || extA && !extB) {
          return false;
        }
        if (!extA && !extB) {
          return true;
        }
        return extA.x[0] === extB.x[0]
            && extA.x[1] === extB.x[1]
            && extA.y[0] === extB.y[0]
            && extA.y[1] === extB.y[1];
      },

      _updateSeriesConfig: function() {
        this.debounce('_updateSeriesConfig', function() {
          // if app doesn't supply seriesConfig, use our default
          const seriesConfig = this.seriesConfig || {
            'series1': {
              'name': 'Series 1',
              'x': 'x',
              'y': 'y',
              'value': 'value'
            }
          };
          // because we only expect a single series, find the first key and assume thats the series key
          this.set('seriesKey', Object.keys(seriesConfig)[0]);
          this.set('completeSeriesConfig', seriesConfig);
        }, 10);
      },

      _updateSeriesKey: function() {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }
        let cells;
        if (this.shadowRoot) {
          cells = this.shadowRoot.querySelectorAll('px-vis-heatmap-cell');
        } else {
          cells = Polymer.dom(this.root).querySelectorAll('px-vis-heatmap-cell');
        }
        cells.forEach((cell) => cell.seriesKey = this.seriesKey);
      },

      _updateColorScale: function() {
        if (!this.dataExtents && !this.chartExtents) {
          return;
        }
        if (!this.colors || this.colors.length < 1) {
          return;
        }
        // get chart min and max values
        const exts = this.chartExtents || this.dataExtents;
        if (!exts.value) {
          return;
        }
        // calculate the value threshold for each color
        const valueThresholds = [];
        const rangePerColor = (exts.value[1] - exts.value[0]) / (this.colors.length - 1);
        for (let i = 0; i < this.colors.length; i++) {
          valueThresholds.push(exts.value[0] + rangePerColor * i);
        }
        // in case of rounding limitations, manually set last value to our max
        valueThresholds[valueThresholds.length - 1] = exts.value[1];
        this.set('_colorScale', Px.d3.scaleLinear()
          .domain(valueThresholds)
          .range(this.colors));
      },

      _updateInternalSize: function() {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }
        this.set('_internalWidth', this._getInternalWidth());
        this.set('_internalHeight', this._getInternalHeight());
      },

      _getInternalWidth: function() {
        let width = this.width;
        // in squareMode we need the both axis to be equal length
        if (this.squareMode) {
          const axisWidth = this.width - this.margin.left - this.margin.right;
          const axisHeight = this.height - this.margin.top - this.margin.bottom;
          // if the width is too large, subtract the difference to make them equal
          if (axisWidth > axisHeight) {
            width -= (axisWidth - axisHeight);
          }
        }
        return width;
      },

      _getInternalHeight: function() {
        let height = this.height;
        // in squareMode we need the both axis to be equal length
        if (this.squareMode) {
          const axisWidth = this.width - this.margin.left - this.margin.right;
          const axisHeight = this.height - this.margin.top - this.margin.bottom;
          // if the width is too large, subtract the difference to make them equal
          if (axisHeight > axisWidth) {
            height -= (axisHeight - axisWidth);
          }
        }
        return height;
      },

      _xAxisConfigChanged: function(xAxisConfig) {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }
        this._applyConfigToElement(xAxisConfig, this.$.xAxis);
      },

      _yAxisConfigChanged: function(yAxisConfig) {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }
        this._applyConfigToElement(yAxisConfig, this.$.yAxis);
      },

      _legendConfigChanged: function(legendConfig) {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }
        // debouncing because this gets called before dom-if that instantiates legend happens
        this.debounce('legend-config-changed', function() {
          let legend;
          if (this.shadowRoot) {
            legend = this.shadowRoot.querySelector('px-vis-heatmap-legend');
          } else {
            legend = Polymer.dom(this.root).querySelector('px-vis-heatmap-legend');
          }
          if (legend) {
            this._applyConfigToElement(legendConfig, legend);
          }
        }.bind(this), 10);
      },

      _handleCellMouseover: function(e, details) {
        // show over cell value if available, otherwise over entire cell
        const el = details.cell.getSvgTextElement() || details.cell.getSvgElement();
        // update hover opacities and the tooltip
        this._setHoveredCell(details.cell, 1, 0.3, this.tooltipDelay);
        this._showTooltip(el, this._createTooltipMessage(details.cell));
      },

      _handleCellMouseout: function(e, details) {
        this._setHoveredCell(null, 1, 1, 0);
        this._closeTooltip();
      },

      _handleCellClick: function(e, detail) {
        // TODO: remove log
        console.info('clicked cell [value=' + detail.value + ']');
      },

      _setHoveredCell: function(hoveredCell, delay) {
        let cells;
        // get all cell components
        if (this.shadowRoot) {
          cells = this.shadowRoot.querySelectorAll('px-vis-heatmap-cell');
        } else {
          cells = Polymer.dom(this.root).querySelectorAll('px-vis-heatmap-cell');
        }
        // lower opacity for all non-hovered elements
        this.debounce('opacityTimeout', () => {
          cells.forEach((cell) => {
            if (!cell || !cell.getSvgElement()) {
              return;
            }
            if (hoveredCell && hoveredCell !== cell) {
              // lower opacity
              cell.getSvgElement().classList.add('primaryDataMask');
            } else {
              // set opacity to default
              cell.getSvgElement().classList.remove('primaryDataMask');
            }
          });
        }, delay);
      },

      _showTooltip: function(el, msg) {
        this.$.tooltip.for = el;
        this.tooltipContent.innerHTML = msg;
        this.$.tooltip.opened = true;
      },

      _closeTooltip: function() {
        this.$.tooltip.opened = false;
      },

      _createTooltipMessage: function(cell) {
        let msg = '<h1 style="text-weight:bold;font-size:125%;">';
        msg += 'Asset ' + cell._getValue('x') + ', ' + cell._getValue('y');
        msg += '</h1>';
        // use parseFloat to be safe of XSS
        msg += cell._getValue('value');
        return msg;
      },

      _resolveCssVars: function() {
        // get series config obj
        const seriesConfig = this.completeSeriesConfig || {};
        const config = seriesConfig[this.seriesKey] || {};
        // resolve all css vars
        this.cellBorderColor = config.cellBorderColor
          || this._checkThemeVariable('--px-vis-heatmap-cell-border-color', '#FFF');
        this.cellBorderWidth = config.cellBorderWidth
          || this._checkThemeVariable('--px-vis-heatmap-cell-border-width', '0');
        this.cellTextColor = config.cellTextColor
          || this._checkThemeVariable('--px-vis-heatmap-cell-text-color', '#000');
        this.cellTextSize = config.cellTextSize
          || this._checkThemeVariable('--px-vis-heatmap-cell-text-size', '12px');
        // notify children
        this.$.xAxis.updateStyles();
        this.$.yAxis.updateStyles();

      },

      _colorsSet: function() {
        this.set('_colorsAreSet', true);
      }

    });
  </script>
</dom-module>
