<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../px-vis/px-vis-scale.html">
<link rel="import" href="../px-vis/px-vis-svg.html">
<link rel="import" href="../px-vis/px-vis-axis.html">

<link rel="import" href="../px-vis/px-vis-behavior-colors.html">
<link rel="import" href="../px-vis/px-vis-behavior-common.html">
<link rel="import" href="../px-vis/px-vis-behavior-chart.html">


<dom-module id="px-vis-heatmap-legend">
  <template>
    <px-vis-scale
      id="scale"
      x-axis-type="linear"
      y-axis-type="linear"
      complete-series-config="[[completeSeriesConfig]]"
      chart-data="[[_emptyChartData]]"
      chart-extents="[[_axisExtents]]"
      data-extents="[[dataExtents]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      x="{{_axisX}}"
      y="{{_axisY}}"
      scale-padding="[[scalePadding]]"
      domain-changed="{{_axisDomainChanged}}">
    </px-vis-scale>
    <!-- y axis -->
    <px-vis-axis
      id="yAxis"
      svg="[[svg]]"
      axis="[[_axisY]]"
      axis-type="linear"
      margin="[[_axisMargin]]"
      width="[[width]]"
      height="[[height]]"
      orientation="right"
      label-position="center"
      prevent-series-bar
      complete-series-config="[[completeSeriesConfig]]"
      muted-series=[[mutedSeries]]
      tick-size-inner="[[tickSizeInner]]"
      domain-changed="[[_axisDomainChanged]]">
    </px-vis-axis>
  </template>
  <script>
    Polymer({

      is: 'px-vis-heatmap-legend',

      behaviors: [
        PxVisBehavior.axisTypes,
        PxVisBehavior.baseSize,
        PxVisBehavior.chartExtents,
        PxVisBehavior.completeSeriesConfig,
        PxVisBehavior.dataExtents,
        PxVisBehavior.margins,
        PxVisBehavior.observerCheck,
        PxVisBehaviorD3.domainUpdate,
        PxVisBehaviorChart.axisConfigs,
        PxVisBehaviorChart.subConfiguration
      ],

      properties: {

        /**
         * Function used to convert chart value to color value.
         */
        colorScale: {
          type: Object
        },

        /**
         * Widht of the color scale legend. This does not include the axis.
         */
        legendWidth: {
          type: Number,
          value: 50
        },

        /**
        * Widht of the entire charting area.
        */
        width: {
          type: Number,
          value: 100,
          notify: true
        },

        /**
        * The height of the entire charting area.
        */
        height: {
          type: Number,
          value: 400,
          notify: true
        },

        /**
         * Debounce time before drawing.
         */
        drawDebounceTime: {
          type: Number,
          value: 100
        },

        /**
         * Length of the yAxis tick marks.
         */
        tickSizeInner: {
          type: Number,
          value: 0
        },

        /**
         * Gap between the heatmap and this legend.
         */
        gapSize: {
          type: Number,
          value: 20
        },

        /**
        * This component doesn't use chartData, but some px-vis
        * comps require a valid chart data object.
        */
        _emptyChartData: {
          type: Array,
          value: function() {
            return [
              {
                x: 0,
                y: 0
              }
            ];
          }
        },

        /**
        * Calculated margin used for the legend's axis.
        */
        _axisMargin: {
          type: Object,
          value: function() {
            return {
              'top': 0,
              'right': 0,
              'bottom': 0,
              'left': 0
            };
          }
        },

        _axisY: {
          type: Function
        },

        _axisX: {
          type: Function
        },

        _axisDomainChanged: {
          type: Boolean,
          value: false
        },

        _axisExtents: {
          type: Object
        }

      },

      observers: [
        '_defineGradient(colorScale)',
        '_drawRectangle(width, height, legendWidth, _axisMargin.*, domainChanged)',
        '_yAxisConfigChanged(yAxisConfig)',
        '_updateAxisMargin(width, height, legendWidth, gapSize, margin.*, x, y, domainChanged)',
        '_updateAxisExtents(_axisDomainChanged, _axisX, _axisY, colorScale)'
      ],

      _updateAxisExtents: function() {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }
        this.set('_axisExtents', this._calcExtents());
      },

      _updateAxisMargin: function() {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }
        let right = this.margin.right - this.legendWidth - this.gapSize;
        right = right >= 0 ? right : 0;
        this.set('_axisMargin', {
          right: right,
          left: this.margin.left,
          top: this.margin.top,
          bottom: this.margin.bottom
        });
      },

      _defineGradient: function() {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }

        this.debounce('define-gradient', function() {
          // remove old gradient and drawing
          if (this.legend) {
            this.legend.remove();
          }
          // calculate new gradient
          const valueThresholds = this.colorScale.domain();
          const valueRange = valueThresholds[valueThresholds.length - 1] - valueThresholds[0];
          const colors = this.colorScale.range();
          // define gradient for our legend drawing to use
          this.legend = this.svg.append('defs').append('svg:linearGradient')
            .attr('id', 'gradient')
            .attr('x1', '100%')
            .attr('y1', '0%')
            .attr('x2', '100%')
            .attr('y2', '100%').attr('spreadMethod', 'pad');
          // because the value min/max are not always 0/100, we need to calculate the percentage
          // for each value threshold in order to build a gradient
          let percentage = 0;
          let lastThreshold = valueThresholds[0];
          colors.forEach((color, i) => {
            percentage += (valueThresholds[i] - lastThreshold) / valueRange * 100;
            lastThreshold = valueThresholds[i];
            // use percentage to draw current color into gradient
            this.legend.append('stop')
              .attr('offset', percentage + '%')
              .attr('stop-color', color)
              .attr('stop-opacity', 1);
          });
        }.bind(this), this.drawDebounceTime);
      },

      _drawRectangle: function() {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }

        this.debounce('draw-rectangle', function() {
          // remove old rectangle element
          if (this.rect) {
            this.rect.remove();
          }
          // update axis extents
          // this.dataExtents = this._calcExtents();
          const exts = this.chartExtents || this.dataExtents;
          // const width = this._axisMargin.right - this.margin.right;
          const height = this.height - this.margin.bottom - this.margin.top;
          const xOffset = this.x(exts.x[exts.x.length - 1]) + this.x.bandwidth() + this.gapSize;
          // xOffset maybe invalid if the x function is being updated
          if (xOffset !== 0 && !xOffset) {
            return;
          }
          this.rect = this.svg.append('rect')
            .attr('width', this.legendWidth)
            .attr('height', height)
            .style('fill', 'url(#gradient)')
            // gradient draws top to bottom, so we need to flip it to match the scale which is bottom to top
            .attr('transform', 'translate(' + xOffset + ') '
              + 'rotate(180, ' + (this.legendWidth / 2) + ', ' + (height / 2) + ') ');
        }.bind(this), this.drawDebounceTime);
      },

      _calcExtents: function() {
        // x and y don't matter, only care about the value
        const exts = {
          x: [0, 1],
          y: [0, 1]
        };
        if (this.colorScale) {
          const values = this.colorScale.domain();
          exts.y = [values[0], values[values.length - 1]];
        }
        return exts;
      },

      _yAxisConfigChanged: function(yAxisConfig) {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }
        this._applyConfigToElement(yAxisConfig, this.$.yAxis);
      }

    });
  </script>
</dom-module>
