<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../px-vis/px-vis-scale.html">
<link rel="import" href="../px-vis/px-vis-svg.html">
<link rel="import" href="../px-vis/px-vis-axis.html">

<link rel="import" href="../px-vis/px-vis-behavior-colors.html">
<link rel="import" href="../px-vis/px-vis-behavior-common.html">
<link rel="import" href="../px-vis/px-vis-behavior-chart.html">


<dom-module id="px-vis-heatmap-legend">
  <template>
    <px-vis-svg
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      svg="{{svg}}">
    </px-vis-svg>
    <px-vis-scale
      id="scale"
      x-axis-type="linear"
      y-axis-type="linear"
      complete-series-config="[[completeSeriesConfig]]"
      chart-data="[[chartData]]"
      chart-extents="[[chartExtents]]"
      data-extents="[[dataExtents]]"
      width="[[width]]"
      height="[[height]]"
      margin="[[margin]]"
      x="{{x}}"
      y="{{y}}"
      scale-padding="[[scalePadding]]"
      domain-changed="{{domainChanged}}">
    </px-vis-scale>
    <!-- y axis -->
    <px-vis-axis
      id="yAxis"
      svg="[[svg]]"
      axis="[[y]]"
      axis-type="linear"
      margin="[[margin]]"
      width="[[width]]"
      height="[[height]]"
      orientation="right"
      label-position="center"
      prevent-series-bar
      complete-series-config="[[completeSeriesConfig]]"
      muted-series=[[mutedSeries]]
      domain-changed="[[domainChanged]]">
    </px-vis-axis>
  </template>
  <script>
    Polymer({

      is: 'px-vis-heatmap-legend',

      behaviors: [
        PxColorsBehavior.dataVisColors,
        PxColorsBehavior.dataVisColorTheming,
        PxColorsBehavior.getSeriesColors,
        PxVisBehavior.axisTypes,
        PxVisBehavior.baseSize,
        PxVisBehavior.chartExtents,
        PxVisBehavior.completeSeriesConfig,
        PxVisBehavior.dataset,
        PxVisBehavior.dataExtents,
        PxVisBehavior.margins,
        PxVisBehavior.observerCheck,
        PxVisBehavior.updateStylesOverride,
        PxVisBehaviorD3.domainUpdate,
        PxVisBehaviorChart.axisConfigs,
        PxVisBehaviorChart.layers,
        PxVisBehaviorChart.subConfiguration
      ],

      properties: {

        /**
        * Container for the data object that drives the chart.
        */
        chartData: {
          type: Array
        },

        /**
         * Function used to convert chart value to color value.
         */
        colorScale: {
          type: Object
        },

        /**
        * The width of the elem; generally the width of the charting area for most components
        */
        width: {
          type: Number,
          value: 100,
          notify: true
        },

        /**
        * The height of the component; generally the height of the charting area for most components.
        */
        height: {
          type: Number,
          value: 400,
          notify: true
        },

        /**
        * Defines the base margin for the chart. Calcs are run to add to the
        * margin to accommodate axes and other elements which exist within the SVG frame,
        * but outside the chart frame.
        */
        margin: {
          type: Object,
          value: function() {
            return {
              'top': 0,
              'right': 50,
              'bottom': 0,
              'left': 0
            };
          }
        },

        dataExtents: {
          type: Object,
          value: function() {
            return {
              x: [0, 2],
              y: [0, 2]
            };
          }
        }

      },

      observers: [
        'drawElement(colorScale, width, height, margin, margin.*, domainChanged)'
      ],

      ready: function() {
      },

      drawElement: function() {
        if (this.hasUndefinedArguments(arguments)) {
          return;
        }

        if (this.legend) {
          this.legend.remove();
        }

        if (this.rect) {
          this.rect.remove();
        }

        const valueThresholds = this.colorScale.domain();
        const valueRange = valueThresholds[valueThresholds.length - 1] - valueThresholds[0];
        const colors = this.colorScale.range();

        // define gradient for our legend drawing to use
        this.legend = this.svg.append('defs').append('svg:linearGradient')
          .attr('id', 'gradient')
          .attr('x1', '100%')
          .attr('y1', '0%')
          .attr('x2', '100%')
          .attr('y2', '100%').attr('spreadMethod', 'pad');

        // because the value min/max are not always 0/100, we need to calculate the percentage
        // for each value threshold in order to build a gradient
        let percentage = 0;
        let lastThreshold = valueThresholds[0];
        colors.forEach((color, i) => {
          percentage += (valueThresholds[i] - lastThreshold) / valueRange * 100;
          lastThreshold = valueThresholds[i];
          // use percentage to draw current color into gradient
          this.legend.append('stop')
            .attr('offset', percentage + '%')
            .attr('stop-color', color)
            .attr('stop-opacity', 1);
        });

        // draw rectangle and fill in with our gradient
        const width = this.width - this.margin.right;
        const height = this.height - this.margin.bottom - this.margin.top;
        this.rect = this.svg.append('rect')
          .attr('width', width)
          .attr('height', height)
          .style('fill', 'url(#gradient)')
          // gradient draws top to bottom, so we need to flip it to match the scale which is bottom to top
          .attr('transform', 'rotate(180, ' + (width / 2) + ', ' + (height / 2) + ')');
      }

    });
  </script>
</dom-module>
